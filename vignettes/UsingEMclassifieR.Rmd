---
title: "Using EMclassifieR on methylation data"
author: "Jennifer Semple"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
suppressMessages(library(EMclassifieR))
```

# The data
DSMF data comes as matrices of reads x positions where each row refers to a single (usually paired-end) read and each column refers to a CpG or GpC position where methylation has been scored. The positions should be in relative coordinates (e.g. -250 to +250 around the TSS), so that matrices from different genes can be compared. 
Some example data is included with the package. First we read in a table with a list of the matrix filenames (including path). The important columns in this table are "filename" and "reads".
```{r}
tablePath="csv/MatrixLog_relCoord_ampTSS.csv"
matTable<-read.csv(system.file("extdata", tablePath, package = "EMclassifieR",
                               mustWork=TRUE), stringsAsFactors=F)
head(matTable)
```

The matrices are in RDS format. For learning it is probably best to process them to remove any reads containing NAs.
```{r}
i=1
dataMatrix<-readRDS(system.file("extdata", matTable$filename[i], package = "EMclassifieR", mustWork=TRUE))
dim(dataMatrix)
dataMatrix<-removeAllNArows(dataMatrix)
dim(dataMatrix)
```


## Learning classes for single genes
To look at one gene at a time one can use the minimal matrix which includes only positions with a CpG or GpC motif in them.

```{r,eval=T}

k_range = 2:8      # Number of classes to be found
maxIterations = 100 # number of iterations of EM clustering to perform if it does not converge
convergenceError = 10e-6
numRepeats=10 # number of repeats of clustering each matrix (to account for fraction of methylation)
xRange=c(-250,250)
maxB=50 # Number of randomised matrices to generate
outPath="./EMres"
maxTasks=4
taskId=1
nThreads=4
setSeed=FALSE
distMetric=list(name="euclidWinDist",winSize=5,stepSize=2)

if(!dir.exists(outPath)){
  dir.create(outPath)
}

#split table indicies into nTasks number of groups
taskSubList<-split(1:nrow(matTable),sort(1:nrow(matTable)%%maxTasks))

set.seed(200413)
for (i in taskSubList[[taskId]]){
#for (i in 1:nrow(matTable)) {
  regionName=matTable$region[i]
  sampleName=matTable$sample[i]
  outFileBase=paste(sampleName, regionName, sep="_")
  print(paste("Clustering", outFileBase))
  dataMatrix<-readRDS(system.file("extdata", matTable$filename[i], 
                              package = "EMclassifieR", mustWork=TRUE))
  dim(dataMatrix)
  dataMatrix<-removeAllNArows(dataMatrix)
  dim(dataMatrix)
  
#   allClassMeans<-tryCatch( 
#     {
#       print("running EM for a range of class numbers")
#       runEMrangeClassNum(dataMatrix, k_range, convergenceError, maxIterations,
#                      EMrepeats=numRepeats, outPath=outPath, xRange=xRange, 
#                      outFileBase=paste(sampleName, regionName, sep="_"),
#                      doIndividualPlots=FALSE, distMetric=distMetric)
#       
#     },
#       error=function(e){"Matrix not valid"}
#   )
#       
#   if(is.list(allClassMeans)){
#      	saveRDS(allClassMeans,paste0(outPath,"/allClassMeans_",outFileBase,".rds"))
#   } else {
#      	print(allClassMeans) # error message
#   }
# 
#   clustMetrics<-tryCatch( 
#     {
# 	    print("plotting clustering metrics for a range of class sizes")
# 	    plotClusteringMetrics(dataMatrix, k_range, maxB, convergenceError,
# 		    maxIterations, outPath, outFileBase, EMrep=NULL, nThreads=nThreads,
# 		    setSeed=setSeed, distMetric=distMetric)
#     },
#     error=function(e){"Matrix not valid"}
#   )
#   if(length(clustMetrics)==1) {
#     print(clustMetrics)
#   }
  
  pcaPlots<-tryCatch( 
    {
      print("plotting PCA of clusters")
      plotPCAmatrices(k_range, outPath, outFileBase)
    },
    error=function(e){"Matrix not valid"}
   )
  if(length(pcaPlots)==1) {
    print(pcaPlots)
  }
  
}

```